package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/repositories/carts_products_repo.ICartsProductsRepo -o ./mocks/i_carts_products_repo_minimock.go -n ICartsProductsRepoMock

import (
	"context"
	"route256/checkout/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ICartsProductsRepoMock implements carts_products_repo.ICartsProductsRepo
type ICartsProductsRepoMock struct {
	t minimock.Tester

	funcAddProductToCart          func(ctx context.Context, CartID uint64, sku uint32, Count uint32) (u1 uint64, err error)
	inspectFuncAddProductToCart   func(ctx context.Context, CartID uint64, sku uint32, Count uint32)
	afterAddProductToCartCounter  uint64
	beforeAddProductToCartCounter uint64
	AddProductToCartMock          mICartsProductsRepoMockAddProductToCart

	funcDeleteProductFromCart          func(ctx context.Context, id uint64) (u1 uint64, err error)
	inspectFuncDeleteProductFromCart   func(ctx context.Context, id uint64)
	afterDeleteProductFromCartCounter  uint64
	beforeDeleteProductFromCartCounter uint64
	DeleteProductFromCartMock          mICartsProductsRepoMockDeleteProductFromCart

	funcGetCartProduct          func(ctx context.Context, sku uint32, userID int64) (ip1 *models.ItemCart, err error)
	inspectFuncGetCartProduct   func(ctx context.Context, sku uint32, userID int64)
	afterGetCartProductCounter  uint64
	beforeGetCartProductCounter uint64
	GetCartProductMock          mICartsProductsRepoMockGetCartProduct

	funcGetCartProductCount          func(ctx context.Context, SKU uint32) (u1 uint32, err error)
	inspectFuncGetCartProductCount   func(ctx context.Context, SKU uint32)
	afterGetCartProductCountCounter  uint64
	beforeGetCartProductCountCounter uint64
	GetCartProductCountMock          mICartsProductsRepoMockGetCartProductCount

	funcGetCartsProducts          func(ctx context.Context, userID int64) (ia1 []models.Item, err error)
	inspectFuncGetCartsProducts   func(ctx context.Context, userID int64)
	afterGetCartsProductsCounter  uint64
	beforeGetCartsProductsCounter uint64
	GetCartsProductsMock          mICartsProductsRepoMockGetCartsProducts

	funcUpdateCartProduct          func(ctx context.Context, sku uint64, count uint32, cartID uint32) (u1 uint64, err error)
	inspectFuncUpdateCartProduct   func(ctx context.Context, sku uint64, count uint32, cartID uint32)
	afterUpdateCartProductCounter  uint64
	beforeUpdateCartProductCounter uint64
	UpdateCartProductMock          mICartsProductsRepoMockUpdateCartProduct
}

// NewICartsProductsRepoMock returns a mock for carts_products_repo.ICartsProductsRepo
func NewICartsProductsRepoMock(t minimock.Tester) *ICartsProductsRepoMock {
	m := &ICartsProductsRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddProductToCartMock = mICartsProductsRepoMockAddProductToCart{mock: m}
	m.AddProductToCartMock.callArgs = []*ICartsProductsRepoMockAddProductToCartParams{}

	m.DeleteProductFromCartMock = mICartsProductsRepoMockDeleteProductFromCart{mock: m}
	m.DeleteProductFromCartMock.callArgs = []*ICartsProductsRepoMockDeleteProductFromCartParams{}

	m.GetCartProductMock = mICartsProductsRepoMockGetCartProduct{mock: m}
	m.GetCartProductMock.callArgs = []*ICartsProductsRepoMockGetCartProductParams{}

	m.GetCartProductCountMock = mICartsProductsRepoMockGetCartProductCount{mock: m}
	m.GetCartProductCountMock.callArgs = []*ICartsProductsRepoMockGetCartProductCountParams{}

	m.GetCartsProductsMock = mICartsProductsRepoMockGetCartsProducts{mock: m}
	m.GetCartsProductsMock.callArgs = []*ICartsProductsRepoMockGetCartsProductsParams{}

	m.UpdateCartProductMock = mICartsProductsRepoMockUpdateCartProduct{mock: m}
	m.UpdateCartProductMock.callArgs = []*ICartsProductsRepoMockUpdateCartProductParams{}

	return m
}

type mICartsProductsRepoMockAddProductToCart struct {
	mock               *ICartsProductsRepoMock
	defaultExpectation *ICartsProductsRepoMockAddProductToCartExpectation
	expectations       []*ICartsProductsRepoMockAddProductToCartExpectation

	callArgs []*ICartsProductsRepoMockAddProductToCartParams
	mutex    sync.RWMutex
}

// ICartsProductsRepoMockAddProductToCartExpectation specifies expectation struct of the ICartsProductsRepo.AddProductToCart
type ICartsProductsRepoMockAddProductToCartExpectation struct {
	mock    *ICartsProductsRepoMock
	params  *ICartsProductsRepoMockAddProductToCartParams
	results *ICartsProductsRepoMockAddProductToCartResults
	Counter uint64
}

// ICartsProductsRepoMockAddProductToCartParams contains parameters of the ICartsProductsRepo.AddProductToCart
type ICartsProductsRepoMockAddProductToCartParams struct {
	ctx    context.Context
	CartID uint64
	sku    uint32
	Count  uint32
}

// ICartsProductsRepoMockAddProductToCartResults contains results of the ICartsProductsRepo.AddProductToCart
type ICartsProductsRepoMockAddProductToCartResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for ICartsProductsRepo.AddProductToCart
func (mmAddProductToCart *mICartsProductsRepoMockAddProductToCart) Expect(ctx context.Context, CartID uint64, sku uint32, Count uint32) *mICartsProductsRepoMockAddProductToCart {
	if mmAddProductToCart.mock.funcAddProductToCart != nil {
		mmAddProductToCart.mock.t.Fatalf("ICartsProductsRepoMock.AddProductToCart mock is already set by Set")
	}

	if mmAddProductToCart.defaultExpectation == nil {
		mmAddProductToCart.defaultExpectation = &ICartsProductsRepoMockAddProductToCartExpectation{}
	}

	mmAddProductToCart.defaultExpectation.params = &ICartsProductsRepoMockAddProductToCartParams{ctx, CartID, sku, Count}
	for _, e := range mmAddProductToCart.expectations {
		if minimock.Equal(e.params, mmAddProductToCart.defaultExpectation.params) {
			mmAddProductToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddProductToCart.defaultExpectation.params)
		}
	}

	return mmAddProductToCart
}

// Inspect accepts an inspector function that has same arguments as the ICartsProductsRepo.AddProductToCart
func (mmAddProductToCart *mICartsProductsRepoMockAddProductToCart) Inspect(f func(ctx context.Context, CartID uint64, sku uint32, Count uint32)) *mICartsProductsRepoMockAddProductToCart {
	if mmAddProductToCart.mock.inspectFuncAddProductToCart != nil {
		mmAddProductToCart.mock.t.Fatalf("Inspect function is already set for ICartsProductsRepoMock.AddProductToCart")
	}

	mmAddProductToCart.mock.inspectFuncAddProductToCart = f

	return mmAddProductToCart
}

// Return sets up results that will be returned by ICartsProductsRepo.AddProductToCart
func (mmAddProductToCart *mICartsProductsRepoMockAddProductToCart) Return(u1 uint64, err error) *ICartsProductsRepoMock {
	if mmAddProductToCart.mock.funcAddProductToCart != nil {
		mmAddProductToCart.mock.t.Fatalf("ICartsProductsRepoMock.AddProductToCart mock is already set by Set")
	}

	if mmAddProductToCart.defaultExpectation == nil {
		mmAddProductToCart.defaultExpectation = &ICartsProductsRepoMockAddProductToCartExpectation{mock: mmAddProductToCart.mock}
	}
	mmAddProductToCart.defaultExpectation.results = &ICartsProductsRepoMockAddProductToCartResults{u1, err}
	return mmAddProductToCart.mock
}

// Set uses given function f to mock the ICartsProductsRepo.AddProductToCart method
func (mmAddProductToCart *mICartsProductsRepoMockAddProductToCart) Set(f func(ctx context.Context, CartID uint64, sku uint32, Count uint32) (u1 uint64, err error)) *ICartsProductsRepoMock {
	if mmAddProductToCart.defaultExpectation != nil {
		mmAddProductToCart.mock.t.Fatalf("Default expectation is already set for the ICartsProductsRepo.AddProductToCart method")
	}

	if len(mmAddProductToCart.expectations) > 0 {
		mmAddProductToCart.mock.t.Fatalf("Some expectations are already set for the ICartsProductsRepo.AddProductToCart method")
	}

	mmAddProductToCart.mock.funcAddProductToCart = f
	return mmAddProductToCart.mock
}

// When sets expectation for the ICartsProductsRepo.AddProductToCart which will trigger the result defined by the following
// Then helper
func (mmAddProductToCart *mICartsProductsRepoMockAddProductToCart) When(ctx context.Context, CartID uint64, sku uint32, Count uint32) *ICartsProductsRepoMockAddProductToCartExpectation {
	if mmAddProductToCart.mock.funcAddProductToCart != nil {
		mmAddProductToCart.mock.t.Fatalf("ICartsProductsRepoMock.AddProductToCart mock is already set by Set")
	}

	expectation := &ICartsProductsRepoMockAddProductToCartExpectation{
		mock:   mmAddProductToCart.mock,
		params: &ICartsProductsRepoMockAddProductToCartParams{ctx, CartID, sku, Count},
	}
	mmAddProductToCart.expectations = append(mmAddProductToCart.expectations, expectation)
	return expectation
}

// Then sets up ICartsProductsRepo.AddProductToCart return parameters for the expectation previously defined by the When method
func (e *ICartsProductsRepoMockAddProductToCartExpectation) Then(u1 uint64, err error) *ICartsProductsRepoMock {
	e.results = &ICartsProductsRepoMockAddProductToCartResults{u1, err}
	return e.mock
}

// AddProductToCart implements carts_products_repo.ICartsProductsRepo
func (mmAddProductToCart *ICartsProductsRepoMock) AddProductToCart(ctx context.Context, CartID uint64, sku uint32, Count uint32) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmAddProductToCart.beforeAddProductToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddProductToCart.afterAddProductToCartCounter, 1)

	if mmAddProductToCart.inspectFuncAddProductToCart != nil {
		mmAddProductToCart.inspectFuncAddProductToCart(ctx, CartID, sku, Count)
	}

	mm_params := &ICartsProductsRepoMockAddProductToCartParams{ctx, CartID, sku, Count}

	// Record call args
	mmAddProductToCart.AddProductToCartMock.mutex.Lock()
	mmAddProductToCart.AddProductToCartMock.callArgs = append(mmAddProductToCart.AddProductToCartMock.callArgs, mm_params)
	mmAddProductToCart.AddProductToCartMock.mutex.Unlock()

	for _, e := range mmAddProductToCart.AddProductToCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmAddProductToCart.AddProductToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddProductToCart.AddProductToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddProductToCart.AddProductToCartMock.defaultExpectation.params
		mm_got := ICartsProductsRepoMockAddProductToCartParams{ctx, CartID, sku, Count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddProductToCart.t.Errorf("ICartsProductsRepoMock.AddProductToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddProductToCart.AddProductToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddProductToCart.t.Fatal("No results are set for the ICartsProductsRepoMock.AddProductToCart")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmAddProductToCart.funcAddProductToCart != nil {
		return mmAddProductToCart.funcAddProductToCart(ctx, CartID, sku, Count)
	}
	mmAddProductToCart.t.Fatalf("Unexpected call to ICartsProductsRepoMock.AddProductToCart. %v %v %v %v", ctx, CartID, sku, Count)
	return
}

// AddProductToCartAfterCounter returns a count of finished ICartsProductsRepoMock.AddProductToCart invocations
func (mmAddProductToCart *ICartsProductsRepoMock) AddProductToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProductToCart.afterAddProductToCartCounter)
}

// AddProductToCartBeforeCounter returns a count of ICartsProductsRepoMock.AddProductToCart invocations
func (mmAddProductToCart *ICartsProductsRepoMock) AddProductToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProductToCart.beforeAddProductToCartCounter)
}

// Calls returns a list of arguments used in each call to ICartsProductsRepoMock.AddProductToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddProductToCart *mICartsProductsRepoMockAddProductToCart) Calls() []*ICartsProductsRepoMockAddProductToCartParams {
	mmAddProductToCart.mutex.RLock()

	argCopy := make([]*ICartsProductsRepoMockAddProductToCartParams, len(mmAddProductToCart.callArgs))
	copy(argCopy, mmAddProductToCart.callArgs)

	mmAddProductToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddProductToCartDone returns true if the count of the AddProductToCart invocations corresponds
// the number of defined expectations
func (m *ICartsProductsRepoMock) MinimockAddProductToCartDone() bool {
	for _, e := range m.AddProductToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddProductToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddProductToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddProductToCart != nil && mm_atomic.LoadUint64(&m.afterAddProductToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddProductToCartInspect logs each unmet expectation
func (m *ICartsProductsRepoMock) MinimockAddProductToCartInspect() {
	for _, e := range m.AddProductToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.AddProductToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddProductToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddProductToCartCounter) < 1 {
		if m.AddProductToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ICartsProductsRepoMock.AddProductToCart")
		} else {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.AddProductToCart with params: %#v", *m.AddProductToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddProductToCart != nil && mm_atomic.LoadUint64(&m.afterAddProductToCartCounter) < 1 {
		m.t.Error("Expected call to ICartsProductsRepoMock.AddProductToCart")
	}
}

type mICartsProductsRepoMockDeleteProductFromCart struct {
	mock               *ICartsProductsRepoMock
	defaultExpectation *ICartsProductsRepoMockDeleteProductFromCartExpectation
	expectations       []*ICartsProductsRepoMockDeleteProductFromCartExpectation

	callArgs []*ICartsProductsRepoMockDeleteProductFromCartParams
	mutex    sync.RWMutex
}

// ICartsProductsRepoMockDeleteProductFromCartExpectation specifies expectation struct of the ICartsProductsRepo.DeleteProductFromCart
type ICartsProductsRepoMockDeleteProductFromCartExpectation struct {
	mock    *ICartsProductsRepoMock
	params  *ICartsProductsRepoMockDeleteProductFromCartParams
	results *ICartsProductsRepoMockDeleteProductFromCartResults
	Counter uint64
}

// ICartsProductsRepoMockDeleteProductFromCartParams contains parameters of the ICartsProductsRepo.DeleteProductFromCart
type ICartsProductsRepoMockDeleteProductFromCartParams struct {
	ctx context.Context
	id  uint64
}

// ICartsProductsRepoMockDeleteProductFromCartResults contains results of the ICartsProductsRepo.DeleteProductFromCart
type ICartsProductsRepoMockDeleteProductFromCartResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for ICartsProductsRepo.DeleteProductFromCart
func (mmDeleteProductFromCart *mICartsProductsRepoMockDeleteProductFromCart) Expect(ctx context.Context, id uint64) *mICartsProductsRepoMockDeleteProductFromCart {
	if mmDeleteProductFromCart.mock.funcDeleteProductFromCart != nil {
		mmDeleteProductFromCart.mock.t.Fatalf("ICartsProductsRepoMock.DeleteProductFromCart mock is already set by Set")
	}

	if mmDeleteProductFromCart.defaultExpectation == nil {
		mmDeleteProductFromCart.defaultExpectation = &ICartsProductsRepoMockDeleteProductFromCartExpectation{}
	}

	mmDeleteProductFromCart.defaultExpectation.params = &ICartsProductsRepoMockDeleteProductFromCartParams{ctx, id}
	for _, e := range mmDeleteProductFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteProductFromCart.defaultExpectation.params) {
			mmDeleteProductFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteProductFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteProductFromCart
}

// Inspect accepts an inspector function that has same arguments as the ICartsProductsRepo.DeleteProductFromCart
func (mmDeleteProductFromCart *mICartsProductsRepoMockDeleteProductFromCart) Inspect(f func(ctx context.Context, id uint64)) *mICartsProductsRepoMockDeleteProductFromCart {
	if mmDeleteProductFromCart.mock.inspectFuncDeleteProductFromCart != nil {
		mmDeleteProductFromCart.mock.t.Fatalf("Inspect function is already set for ICartsProductsRepoMock.DeleteProductFromCart")
	}

	mmDeleteProductFromCart.mock.inspectFuncDeleteProductFromCart = f

	return mmDeleteProductFromCart
}

// Return sets up results that will be returned by ICartsProductsRepo.DeleteProductFromCart
func (mmDeleteProductFromCart *mICartsProductsRepoMockDeleteProductFromCart) Return(u1 uint64, err error) *ICartsProductsRepoMock {
	if mmDeleteProductFromCart.mock.funcDeleteProductFromCart != nil {
		mmDeleteProductFromCart.mock.t.Fatalf("ICartsProductsRepoMock.DeleteProductFromCart mock is already set by Set")
	}

	if mmDeleteProductFromCart.defaultExpectation == nil {
		mmDeleteProductFromCart.defaultExpectation = &ICartsProductsRepoMockDeleteProductFromCartExpectation{mock: mmDeleteProductFromCart.mock}
	}
	mmDeleteProductFromCart.defaultExpectation.results = &ICartsProductsRepoMockDeleteProductFromCartResults{u1, err}
	return mmDeleteProductFromCart.mock
}

// Set uses given function f to mock the ICartsProductsRepo.DeleteProductFromCart method
func (mmDeleteProductFromCart *mICartsProductsRepoMockDeleteProductFromCart) Set(f func(ctx context.Context, id uint64) (u1 uint64, err error)) *ICartsProductsRepoMock {
	if mmDeleteProductFromCart.defaultExpectation != nil {
		mmDeleteProductFromCart.mock.t.Fatalf("Default expectation is already set for the ICartsProductsRepo.DeleteProductFromCart method")
	}

	if len(mmDeleteProductFromCart.expectations) > 0 {
		mmDeleteProductFromCart.mock.t.Fatalf("Some expectations are already set for the ICartsProductsRepo.DeleteProductFromCart method")
	}

	mmDeleteProductFromCart.mock.funcDeleteProductFromCart = f
	return mmDeleteProductFromCart.mock
}

// When sets expectation for the ICartsProductsRepo.DeleteProductFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteProductFromCart *mICartsProductsRepoMockDeleteProductFromCart) When(ctx context.Context, id uint64) *ICartsProductsRepoMockDeleteProductFromCartExpectation {
	if mmDeleteProductFromCart.mock.funcDeleteProductFromCart != nil {
		mmDeleteProductFromCart.mock.t.Fatalf("ICartsProductsRepoMock.DeleteProductFromCart mock is already set by Set")
	}

	expectation := &ICartsProductsRepoMockDeleteProductFromCartExpectation{
		mock:   mmDeleteProductFromCart.mock,
		params: &ICartsProductsRepoMockDeleteProductFromCartParams{ctx, id},
	}
	mmDeleteProductFromCart.expectations = append(mmDeleteProductFromCart.expectations, expectation)
	return expectation
}

// Then sets up ICartsProductsRepo.DeleteProductFromCart return parameters for the expectation previously defined by the When method
func (e *ICartsProductsRepoMockDeleteProductFromCartExpectation) Then(u1 uint64, err error) *ICartsProductsRepoMock {
	e.results = &ICartsProductsRepoMockDeleteProductFromCartResults{u1, err}
	return e.mock
}

// DeleteProductFromCart implements carts_products_repo.ICartsProductsRepo
func (mmDeleteProductFromCart *ICartsProductsRepoMock) DeleteProductFromCart(ctx context.Context, id uint64) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmDeleteProductFromCart.beforeDeleteProductFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteProductFromCart.afterDeleteProductFromCartCounter, 1)

	if mmDeleteProductFromCart.inspectFuncDeleteProductFromCart != nil {
		mmDeleteProductFromCart.inspectFuncDeleteProductFromCart(ctx, id)
	}

	mm_params := &ICartsProductsRepoMockDeleteProductFromCartParams{ctx, id}

	// Record call args
	mmDeleteProductFromCart.DeleteProductFromCartMock.mutex.Lock()
	mmDeleteProductFromCart.DeleteProductFromCartMock.callArgs = append(mmDeleteProductFromCart.DeleteProductFromCartMock.callArgs, mm_params)
	mmDeleteProductFromCart.DeleteProductFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteProductFromCart.DeleteProductFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmDeleteProductFromCart.DeleteProductFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteProductFromCart.DeleteProductFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteProductFromCart.DeleteProductFromCartMock.defaultExpectation.params
		mm_got := ICartsProductsRepoMockDeleteProductFromCartParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteProductFromCart.t.Errorf("ICartsProductsRepoMock.DeleteProductFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteProductFromCart.DeleteProductFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteProductFromCart.t.Fatal("No results are set for the ICartsProductsRepoMock.DeleteProductFromCart")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmDeleteProductFromCart.funcDeleteProductFromCart != nil {
		return mmDeleteProductFromCart.funcDeleteProductFromCart(ctx, id)
	}
	mmDeleteProductFromCart.t.Fatalf("Unexpected call to ICartsProductsRepoMock.DeleteProductFromCart. %v %v", ctx, id)
	return
}

// DeleteProductFromCartAfterCounter returns a count of finished ICartsProductsRepoMock.DeleteProductFromCart invocations
func (mmDeleteProductFromCart *ICartsProductsRepoMock) DeleteProductFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProductFromCart.afterDeleteProductFromCartCounter)
}

// DeleteProductFromCartBeforeCounter returns a count of ICartsProductsRepoMock.DeleteProductFromCart invocations
func (mmDeleteProductFromCart *ICartsProductsRepoMock) DeleteProductFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProductFromCart.beforeDeleteProductFromCartCounter)
}

// Calls returns a list of arguments used in each call to ICartsProductsRepoMock.DeleteProductFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteProductFromCart *mICartsProductsRepoMockDeleteProductFromCart) Calls() []*ICartsProductsRepoMockDeleteProductFromCartParams {
	mmDeleteProductFromCart.mutex.RLock()

	argCopy := make([]*ICartsProductsRepoMockDeleteProductFromCartParams, len(mmDeleteProductFromCart.callArgs))
	copy(argCopy, mmDeleteProductFromCart.callArgs)

	mmDeleteProductFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteProductFromCartDone returns true if the count of the DeleteProductFromCart invocations corresponds
// the number of defined expectations
func (m *ICartsProductsRepoMock) MinimockDeleteProductFromCartDone() bool {
	for _, e := range m.DeleteProductFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteProductFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteProductFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteProductFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteProductFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteProductFromCartInspect logs each unmet expectation
func (m *ICartsProductsRepoMock) MinimockDeleteProductFromCartInspect() {
	for _, e := range m.DeleteProductFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.DeleteProductFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteProductFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteProductFromCartCounter) < 1 {
		if m.DeleteProductFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ICartsProductsRepoMock.DeleteProductFromCart")
		} else {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.DeleteProductFromCart with params: %#v", *m.DeleteProductFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteProductFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteProductFromCartCounter) < 1 {
		m.t.Error("Expected call to ICartsProductsRepoMock.DeleteProductFromCart")
	}
}

type mICartsProductsRepoMockGetCartProduct struct {
	mock               *ICartsProductsRepoMock
	defaultExpectation *ICartsProductsRepoMockGetCartProductExpectation
	expectations       []*ICartsProductsRepoMockGetCartProductExpectation

	callArgs []*ICartsProductsRepoMockGetCartProductParams
	mutex    sync.RWMutex
}

// ICartsProductsRepoMockGetCartProductExpectation specifies expectation struct of the ICartsProductsRepo.GetCartProduct
type ICartsProductsRepoMockGetCartProductExpectation struct {
	mock    *ICartsProductsRepoMock
	params  *ICartsProductsRepoMockGetCartProductParams
	results *ICartsProductsRepoMockGetCartProductResults
	Counter uint64
}

// ICartsProductsRepoMockGetCartProductParams contains parameters of the ICartsProductsRepo.GetCartProduct
type ICartsProductsRepoMockGetCartProductParams struct {
	ctx    context.Context
	sku    uint32
	userID int64
}

// ICartsProductsRepoMockGetCartProductResults contains results of the ICartsProductsRepo.GetCartProduct
type ICartsProductsRepoMockGetCartProductResults struct {
	ip1 *models.ItemCart
	err error
}

// Expect sets up expected params for ICartsProductsRepo.GetCartProduct
func (mmGetCartProduct *mICartsProductsRepoMockGetCartProduct) Expect(ctx context.Context, sku uint32, userID int64) *mICartsProductsRepoMockGetCartProduct {
	if mmGetCartProduct.mock.funcGetCartProduct != nil {
		mmGetCartProduct.mock.t.Fatalf("ICartsProductsRepoMock.GetCartProduct mock is already set by Set")
	}

	if mmGetCartProduct.defaultExpectation == nil {
		mmGetCartProduct.defaultExpectation = &ICartsProductsRepoMockGetCartProductExpectation{}
	}

	mmGetCartProduct.defaultExpectation.params = &ICartsProductsRepoMockGetCartProductParams{ctx, sku, userID}
	for _, e := range mmGetCartProduct.expectations {
		if minimock.Equal(e.params, mmGetCartProduct.defaultExpectation.params) {
			mmGetCartProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartProduct.defaultExpectation.params)
		}
	}

	return mmGetCartProduct
}

// Inspect accepts an inspector function that has same arguments as the ICartsProductsRepo.GetCartProduct
func (mmGetCartProduct *mICartsProductsRepoMockGetCartProduct) Inspect(f func(ctx context.Context, sku uint32, userID int64)) *mICartsProductsRepoMockGetCartProduct {
	if mmGetCartProduct.mock.inspectFuncGetCartProduct != nil {
		mmGetCartProduct.mock.t.Fatalf("Inspect function is already set for ICartsProductsRepoMock.GetCartProduct")
	}

	mmGetCartProduct.mock.inspectFuncGetCartProduct = f

	return mmGetCartProduct
}

// Return sets up results that will be returned by ICartsProductsRepo.GetCartProduct
func (mmGetCartProduct *mICartsProductsRepoMockGetCartProduct) Return(ip1 *models.ItemCart, err error) *ICartsProductsRepoMock {
	if mmGetCartProduct.mock.funcGetCartProduct != nil {
		mmGetCartProduct.mock.t.Fatalf("ICartsProductsRepoMock.GetCartProduct mock is already set by Set")
	}

	if mmGetCartProduct.defaultExpectation == nil {
		mmGetCartProduct.defaultExpectation = &ICartsProductsRepoMockGetCartProductExpectation{mock: mmGetCartProduct.mock}
	}
	mmGetCartProduct.defaultExpectation.results = &ICartsProductsRepoMockGetCartProductResults{ip1, err}
	return mmGetCartProduct.mock
}

// Set uses given function f to mock the ICartsProductsRepo.GetCartProduct method
func (mmGetCartProduct *mICartsProductsRepoMockGetCartProduct) Set(f func(ctx context.Context, sku uint32, userID int64) (ip1 *models.ItemCart, err error)) *ICartsProductsRepoMock {
	if mmGetCartProduct.defaultExpectation != nil {
		mmGetCartProduct.mock.t.Fatalf("Default expectation is already set for the ICartsProductsRepo.GetCartProduct method")
	}

	if len(mmGetCartProduct.expectations) > 0 {
		mmGetCartProduct.mock.t.Fatalf("Some expectations are already set for the ICartsProductsRepo.GetCartProduct method")
	}

	mmGetCartProduct.mock.funcGetCartProduct = f
	return mmGetCartProduct.mock
}

// When sets expectation for the ICartsProductsRepo.GetCartProduct which will trigger the result defined by the following
// Then helper
func (mmGetCartProduct *mICartsProductsRepoMockGetCartProduct) When(ctx context.Context, sku uint32, userID int64) *ICartsProductsRepoMockGetCartProductExpectation {
	if mmGetCartProduct.mock.funcGetCartProduct != nil {
		mmGetCartProduct.mock.t.Fatalf("ICartsProductsRepoMock.GetCartProduct mock is already set by Set")
	}

	expectation := &ICartsProductsRepoMockGetCartProductExpectation{
		mock:   mmGetCartProduct.mock,
		params: &ICartsProductsRepoMockGetCartProductParams{ctx, sku, userID},
	}
	mmGetCartProduct.expectations = append(mmGetCartProduct.expectations, expectation)
	return expectation
}

// Then sets up ICartsProductsRepo.GetCartProduct return parameters for the expectation previously defined by the When method
func (e *ICartsProductsRepoMockGetCartProductExpectation) Then(ip1 *models.ItemCart, err error) *ICartsProductsRepoMock {
	e.results = &ICartsProductsRepoMockGetCartProductResults{ip1, err}
	return e.mock
}

// GetCartProduct implements carts_products_repo.ICartsProductsRepo
func (mmGetCartProduct *ICartsProductsRepoMock) GetCartProduct(ctx context.Context, sku uint32, userID int64) (ip1 *models.ItemCart, err error) {
	mm_atomic.AddUint64(&mmGetCartProduct.beforeGetCartProductCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartProduct.afterGetCartProductCounter, 1)

	if mmGetCartProduct.inspectFuncGetCartProduct != nil {
		mmGetCartProduct.inspectFuncGetCartProduct(ctx, sku, userID)
	}

	mm_params := &ICartsProductsRepoMockGetCartProductParams{ctx, sku, userID}

	// Record call args
	mmGetCartProduct.GetCartProductMock.mutex.Lock()
	mmGetCartProduct.GetCartProductMock.callArgs = append(mmGetCartProduct.GetCartProductMock.callArgs, mm_params)
	mmGetCartProduct.GetCartProductMock.mutex.Unlock()

	for _, e := range mmGetCartProduct.GetCartProductMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmGetCartProduct.GetCartProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartProduct.GetCartProductMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartProduct.GetCartProductMock.defaultExpectation.params
		mm_got := ICartsProductsRepoMockGetCartProductParams{ctx, sku, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartProduct.t.Errorf("ICartsProductsRepoMock.GetCartProduct got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartProduct.GetCartProductMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartProduct.t.Fatal("No results are set for the ICartsProductsRepoMock.GetCartProduct")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmGetCartProduct.funcGetCartProduct != nil {
		return mmGetCartProduct.funcGetCartProduct(ctx, sku, userID)
	}
	mmGetCartProduct.t.Fatalf("Unexpected call to ICartsProductsRepoMock.GetCartProduct. %v %v %v", ctx, sku, userID)
	return
}

// GetCartProductAfterCounter returns a count of finished ICartsProductsRepoMock.GetCartProduct invocations
func (mmGetCartProduct *ICartsProductsRepoMock) GetCartProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartProduct.afterGetCartProductCounter)
}

// GetCartProductBeforeCounter returns a count of ICartsProductsRepoMock.GetCartProduct invocations
func (mmGetCartProduct *ICartsProductsRepoMock) GetCartProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartProduct.beforeGetCartProductCounter)
}

// Calls returns a list of arguments used in each call to ICartsProductsRepoMock.GetCartProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartProduct *mICartsProductsRepoMockGetCartProduct) Calls() []*ICartsProductsRepoMockGetCartProductParams {
	mmGetCartProduct.mutex.RLock()

	argCopy := make([]*ICartsProductsRepoMockGetCartProductParams, len(mmGetCartProduct.callArgs))
	copy(argCopy, mmGetCartProduct.callArgs)

	mmGetCartProduct.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartProductDone returns true if the count of the GetCartProduct invocations corresponds
// the number of defined expectations
func (m *ICartsProductsRepoMock) MinimockGetCartProductDone() bool {
	for _, e := range m.GetCartProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartProductCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartProduct != nil && mm_atomic.LoadUint64(&m.afterGetCartProductCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartProductInspect logs each unmet expectation
func (m *ICartsProductsRepoMock) MinimockGetCartProductInspect() {
	for _, e := range m.GetCartProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.GetCartProduct with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartProductCounter) < 1 {
		if m.GetCartProductMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ICartsProductsRepoMock.GetCartProduct")
		} else {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.GetCartProduct with params: %#v", *m.GetCartProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartProduct != nil && mm_atomic.LoadUint64(&m.afterGetCartProductCounter) < 1 {
		m.t.Error("Expected call to ICartsProductsRepoMock.GetCartProduct")
	}
}

type mICartsProductsRepoMockGetCartProductCount struct {
	mock               *ICartsProductsRepoMock
	defaultExpectation *ICartsProductsRepoMockGetCartProductCountExpectation
	expectations       []*ICartsProductsRepoMockGetCartProductCountExpectation

	callArgs []*ICartsProductsRepoMockGetCartProductCountParams
	mutex    sync.RWMutex
}

// ICartsProductsRepoMockGetCartProductCountExpectation specifies expectation struct of the ICartsProductsRepo.GetCartProductCount
type ICartsProductsRepoMockGetCartProductCountExpectation struct {
	mock    *ICartsProductsRepoMock
	params  *ICartsProductsRepoMockGetCartProductCountParams
	results *ICartsProductsRepoMockGetCartProductCountResults
	Counter uint64
}

// ICartsProductsRepoMockGetCartProductCountParams contains parameters of the ICartsProductsRepo.GetCartProductCount
type ICartsProductsRepoMockGetCartProductCountParams struct {
	ctx context.Context
	SKU uint32
}

// ICartsProductsRepoMockGetCartProductCountResults contains results of the ICartsProductsRepo.GetCartProductCount
type ICartsProductsRepoMockGetCartProductCountResults struct {
	u1  uint32
	err error
}

// Expect sets up expected params for ICartsProductsRepo.GetCartProductCount
func (mmGetCartProductCount *mICartsProductsRepoMockGetCartProductCount) Expect(ctx context.Context, SKU uint32) *mICartsProductsRepoMockGetCartProductCount {
	if mmGetCartProductCount.mock.funcGetCartProductCount != nil {
		mmGetCartProductCount.mock.t.Fatalf("ICartsProductsRepoMock.GetCartProductCount mock is already set by Set")
	}

	if mmGetCartProductCount.defaultExpectation == nil {
		mmGetCartProductCount.defaultExpectation = &ICartsProductsRepoMockGetCartProductCountExpectation{}
	}

	mmGetCartProductCount.defaultExpectation.params = &ICartsProductsRepoMockGetCartProductCountParams{ctx, SKU}
	for _, e := range mmGetCartProductCount.expectations {
		if minimock.Equal(e.params, mmGetCartProductCount.defaultExpectation.params) {
			mmGetCartProductCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartProductCount.defaultExpectation.params)
		}
	}

	return mmGetCartProductCount
}

// Inspect accepts an inspector function that has same arguments as the ICartsProductsRepo.GetCartProductCount
func (mmGetCartProductCount *mICartsProductsRepoMockGetCartProductCount) Inspect(f func(ctx context.Context, SKU uint32)) *mICartsProductsRepoMockGetCartProductCount {
	if mmGetCartProductCount.mock.inspectFuncGetCartProductCount != nil {
		mmGetCartProductCount.mock.t.Fatalf("Inspect function is already set for ICartsProductsRepoMock.GetCartProductCount")
	}

	mmGetCartProductCount.mock.inspectFuncGetCartProductCount = f

	return mmGetCartProductCount
}

// Return sets up results that will be returned by ICartsProductsRepo.GetCartProductCount
func (mmGetCartProductCount *mICartsProductsRepoMockGetCartProductCount) Return(u1 uint32, err error) *ICartsProductsRepoMock {
	if mmGetCartProductCount.mock.funcGetCartProductCount != nil {
		mmGetCartProductCount.mock.t.Fatalf("ICartsProductsRepoMock.GetCartProductCount mock is already set by Set")
	}

	if mmGetCartProductCount.defaultExpectation == nil {
		mmGetCartProductCount.defaultExpectation = &ICartsProductsRepoMockGetCartProductCountExpectation{mock: mmGetCartProductCount.mock}
	}
	mmGetCartProductCount.defaultExpectation.results = &ICartsProductsRepoMockGetCartProductCountResults{u1, err}
	return mmGetCartProductCount.mock
}

// Set uses given function f to mock the ICartsProductsRepo.GetCartProductCount method
func (mmGetCartProductCount *mICartsProductsRepoMockGetCartProductCount) Set(f func(ctx context.Context, SKU uint32) (u1 uint32, err error)) *ICartsProductsRepoMock {
	if mmGetCartProductCount.defaultExpectation != nil {
		mmGetCartProductCount.mock.t.Fatalf("Default expectation is already set for the ICartsProductsRepo.GetCartProductCount method")
	}

	if len(mmGetCartProductCount.expectations) > 0 {
		mmGetCartProductCount.mock.t.Fatalf("Some expectations are already set for the ICartsProductsRepo.GetCartProductCount method")
	}

	mmGetCartProductCount.mock.funcGetCartProductCount = f
	return mmGetCartProductCount.mock
}

// When sets expectation for the ICartsProductsRepo.GetCartProductCount which will trigger the result defined by the following
// Then helper
func (mmGetCartProductCount *mICartsProductsRepoMockGetCartProductCount) When(ctx context.Context, SKU uint32) *ICartsProductsRepoMockGetCartProductCountExpectation {
	if mmGetCartProductCount.mock.funcGetCartProductCount != nil {
		mmGetCartProductCount.mock.t.Fatalf("ICartsProductsRepoMock.GetCartProductCount mock is already set by Set")
	}

	expectation := &ICartsProductsRepoMockGetCartProductCountExpectation{
		mock:   mmGetCartProductCount.mock,
		params: &ICartsProductsRepoMockGetCartProductCountParams{ctx, SKU},
	}
	mmGetCartProductCount.expectations = append(mmGetCartProductCount.expectations, expectation)
	return expectation
}

// Then sets up ICartsProductsRepo.GetCartProductCount return parameters for the expectation previously defined by the When method
func (e *ICartsProductsRepoMockGetCartProductCountExpectation) Then(u1 uint32, err error) *ICartsProductsRepoMock {
	e.results = &ICartsProductsRepoMockGetCartProductCountResults{u1, err}
	return e.mock
}

// GetCartProductCount implements carts_products_repo.ICartsProductsRepo
func (mmGetCartProductCount *ICartsProductsRepoMock) GetCartProductCount(ctx context.Context, SKU uint32) (u1 uint32, err error) {
	mm_atomic.AddUint64(&mmGetCartProductCount.beforeGetCartProductCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartProductCount.afterGetCartProductCountCounter, 1)

	if mmGetCartProductCount.inspectFuncGetCartProductCount != nil {
		mmGetCartProductCount.inspectFuncGetCartProductCount(ctx, SKU)
	}

	mm_params := &ICartsProductsRepoMockGetCartProductCountParams{ctx, SKU}

	// Record call args
	mmGetCartProductCount.GetCartProductCountMock.mutex.Lock()
	mmGetCartProductCount.GetCartProductCountMock.callArgs = append(mmGetCartProductCount.GetCartProductCountMock.callArgs, mm_params)
	mmGetCartProductCount.GetCartProductCountMock.mutex.Unlock()

	for _, e := range mmGetCartProductCount.GetCartProductCountMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetCartProductCount.GetCartProductCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartProductCount.GetCartProductCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartProductCount.GetCartProductCountMock.defaultExpectation.params
		mm_got := ICartsProductsRepoMockGetCartProductCountParams{ctx, SKU}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartProductCount.t.Errorf("ICartsProductsRepoMock.GetCartProductCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartProductCount.GetCartProductCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartProductCount.t.Fatal("No results are set for the ICartsProductsRepoMock.GetCartProductCount")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetCartProductCount.funcGetCartProductCount != nil {
		return mmGetCartProductCount.funcGetCartProductCount(ctx, SKU)
	}
	mmGetCartProductCount.t.Fatalf("Unexpected call to ICartsProductsRepoMock.GetCartProductCount. %v %v", ctx, SKU)
	return
}

// GetCartProductCountAfterCounter returns a count of finished ICartsProductsRepoMock.GetCartProductCount invocations
func (mmGetCartProductCount *ICartsProductsRepoMock) GetCartProductCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartProductCount.afterGetCartProductCountCounter)
}

// GetCartProductCountBeforeCounter returns a count of ICartsProductsRepoMock.GetCartProductCount invocations
func (mmGetCartProductCount *ICartsProductsRepoMock) GetCartProductCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartProductCount.beforeGetCartProductCountCounter)
}

// Calls returns a list of arguments used in each call to ICartsProductsRepoMock.GetCartProductCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartProductCount *mICartsProductsRepoMockGetCartProductCount) Calls() []*ICartsProductsRepoMockGetCartProductCountParams {
	mmGetCartProductCount.mutex.RLock()

	argCopy := make([]*ICartsProductsRepoMockGetCartProductCountParams, len(mmGetCartProductCount.callArgs))
	copy(argCopy, mmGetCartProductCount.callArgs)

	mmGetCartProductCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartProductCountDone returns true if the count of the GetCartProductCount invocations corresponds
// the number of defined expectations
func (m *ICartsProductsRepoMock) MinimockGetCartProductCountDone() bool {
	for _, e := range m.GetCartProductCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartProductCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartProductCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartProductCount != nil && mm_atomic.LoadUint64(&m.afterGetCartProductCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartProductCountInspect logs each unmet expectation
func (m *ICartsProductsRepoMock) MinimockGetCartProductCountInspect() {
	for _, e := range m.GetCartProductCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.GetCartProductCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartProductCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartProductCountCounter) < 1 {
		if m.GetCartProductCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ICartsProductsRepoMock.GetCartProductCount")
		} else {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.GetCartProductCount with params: %#v", *m.GetCartProductCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartProductCount != nil && mm_atomic.LoadUint64(&m.afterGetCartProductCountCounter) < 1 {
		m.t.Error("Expected call to ICartsProductsRepoMock.GetCartProductCount")
	}
}

type mICartsProductsRepoMockGetCartsProducts struct {
	mock               *ICartsProductsRepoMock
	defaultExpectation *ICartsProductsRepoMockGetCartsProductsExpectation
	expectations       []*ICartsProductsRepoMockGetCartsProductsExpectation

	callArgs []*ICartsProductsRepoMockGetCartsProductsParams
	mutex    sync.RWMutex
}

// ICartsProductsRepoMockGetCartsProductsExpectation specifies expectation struct of the ICartsProductsRepo.GetCartsProducts
type ICartsProductsRepoMockGetCartsProductsExpectation struct {
	mock    *ICartsProductsRepoMock
	params  *ICartsProductsRepoMockGetCartsProductsParams
	results *ICartsProductsRepoMockGetCartsProductsResults
	Counter uint64
}

// ICartsProductsRepoMockGetCartsProductsParams contains parameters of the ICartsProductsRepo.GetCartsProducts
type ICartsProductsRepoMockGetCartsProductsParams struct {
	ctx    context.Context
	userID int64
}

// ICartsProductsRepoMockGetCartsProductsResults contains results of the ICartsProductsRepo.GetCartsProducts
type ICartsProductsRepoMockGetCartsProductsResults struct {
	ia1 []models.Item
	err error
}

// Expect sets up expected params for ICartsProductsRepo.GetCartsProducts
func (mmGetCartsProducts *mICartsProductsRepoMockGetCartsProducts) Expect(ctx context.Context, userID int64) *mICartsProductsRepoMockGetCartsProducts {
	if mmGetCartsProducts.mock.funcGetCartsProducts != nil {
		mmGetCartsProducts.mock.t.Fatalf("ICartsProductsRepoMock.GetCartsProducts mock is already set by Set")
	}

	if mmGetCartsProducts.defaultExpectation == nil {
		mmGetCartsProducts.defaultExpectation = &ICartsProductsRepoMockGetCartsProductsExpectation{}
	}

	mmGetCartsProducts.defaultExpectation.params = &ICartsProductsRepoMockGetCartsProductsParams{ctx, userID}
	for _, e := range mmGetCartsProducts.expectations {
		if minimock.Equal(e.params, mmGetCartsProducts.defaultExpectation.params) {
			mmGetCartsProducts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartsProducts.defaultExpectation.params)
		}
	}

	return mmGetCartsProducts
}

// Inspect accepts an inspector function that has same arguments as the ICartsProductsRepo.GetCartsProducts
func (mmGetCartsProducts *mICartsProductsRepoMockGetCartsProducts) Inspect(f func(ctx context.Context, userID int64)) *mICartsProductsRepoMockGetCartsProducts {
	if mmGetCartsProducts.mock.inspectFuncGetCartsProducts != nil {
		mmGetCartsProducts.mock.t.Fatalf("Inspect function is already set for ICartsProductsRepoMock.GetCartsProducts")
	}

	mmGetCartsProducts.mock.inspectFuncGetCartsProducts = f

	return mmGetCartsProducts
}

// Return sets up results that will be returned by ICartsProductsRepo.GetCartsProducts
func (mmGetCartsProducts *mICartsProductsRepoMockGetCartsProducts) Return(ia1 []models.Item, err error) *ICartsProductsRepoMock {
	if mmGetCartsProducts.mock.funcGetCartsProducts != nil {
		mmGetCartsProducts.mock.t.Fatalf("ICartsProductsRepoMock.GetCartsProducts mock is already set by Set")
	}

	if mmGetCartsProducts.defaultExpectation == nil {
		mmGetCartsProducts.defaultExpectation = &ICartsProductsRepoMockGetCartsProductsExpectation{mock: mmGetCartsProducts.mock}
	}
	mmGetCartsProducts.defaultExpectation.results = &ICartsProductsRepoMockGetCartsProductsResults{ia1, err}
	return mmGetCartsProducts.mock
}

// Set uses given function f to mock the ICartsProductsRepo.GetCartsProducts method
func (mmGetCartsProducts *mICartsProductsRepoMockGetCartsProducts) Set(f func(ctx context.Context, userID int64) (ia1 []models.Item, err error)) *ICartsProductsRepoMock {
	if mmGetCartsProducts.defaultExpectation != nil {
		mmGetCartsProducts.mock.t.Fatalf("Default expectation is already set for the ICartsProductsRepo.GetCartsProducts method")
	}

	if len(mmGetCartsProducts.expectations) > 0 {
		mmGetCartsProducts.mock.t.Fatalf("Some expectations are already set for the ICartsProductsRepo.GetCartsProducts method")
	}

	mmGetCartsProducts.mock.funcGetCartsProducts = f
	return mmGetCartsProducts.mock
}

// When sets expectation for the ICartsProductsRepo.GetCartsProducts which will trigger the result defined by the following
// Then helper
func (mmGetCartsProducts *mICartsProductsRepoMockGetCartsProducts) When(ctx context.Context, userID int64) *ICartsProductsRepoMockGetCartsProductsExpectation {
	if mmGetCartsProducts.mock.funcGetCartsProducts != nil {
		mmGetCartsProducts.mock.t.Fatalf("ICartsProductsRepoMock.GetCartsProducts mock is already set by Set")
	}

	expectation := &ICartsProductsRepoMockGetCartsProductsExpectation{
		mock:   mmGetCartsProducts.mock,
		params: &ICartsProductsRepoMockGetCartsProductsParams{ctx, userID},
	}
	mmGetCartsProducts.expectations = append(mmGetCartsProducts.expectations, expectation)
	return expectation
}

// Then sets up ICartsProductsRepo.GetCartsProducts return parameters for the expectation previously defined by the When method
func (e *ICartsProductsRepoMockGetCartsProductsExpectation) Then(ia1 []models.Item, err error) *ICartsProductsRepoMock {
	e.results = &ICartsProductsRepoMockGetCartsProductsResults{ia1, err}
	return e.mock
}

// GetCartsProducts implements carts_products_repo.ICartsProductsRepo
func (mmGetCartsProducts *ICartsProductsRepoMock) GetCartsProducts(ctx context.Context, userID int64) (ia1 []models.Item, err error) {
	mm_atomic.AddUint64(&mmGetCartsProducts.beforeGetCartsProductsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartsProducts.afterGetCartsProductsCounter, 1)

	if mmGetCartsProducts.inspectFuncGetCartsProducts != nil {
		mmGetCartsProducts.inspectFuncGetCartsProducts(ctx, userID)
	}

	mm_params := &ICartsProductsRepoMockGetCartsProductsParams{ctx, userID}

	// Record call args
	mmGetCartsProducts.GetCartsProductsMock.mutex.Lock()
	mmGetCartsProducts.GetCartsProductsMock.callArgs = append(mmGetCartsProducts.GetCartsProductsMock.callArgs, mm_params)
	mmGetCartsProducts.GetCartsProductsMock.mutex.Unlock()

	for _, e := range mmGetCartsProducts.GetCartsProductsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetCartsProducts.GetCartsProductsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartsProducts.GetCartsProductsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartsProducts.GetCartsProductsMock.defaultExpectation.params
		mm_got := ICartsProductsRepoMockGetCartsProductsParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartsProducts.t.Errorf("ICartsProductsRepoMock.GetCartsProducts got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartsProducts.GetCartsProductsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartsProducts.t.Fatal("No results are set for the ICartsProductsRepoMock.GetCartsProducts")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetCartsProducts.funcGetCartsProducts != nil {
		return mmGetCartsProducts.funcGetCartsProducts(ctx, userID)
	}
	mmGetCartsProducts.t.Fatalf("Unexpected call to ICartsProductsRepoMock.GetCartsProducts. %v %v", ctx, userID)
	return
}

// GetCartsProductsAfterCounter returns a count of finished ICartsProductsRepoMock.GetCartsProducts invocations
func (mmGetCartsProducts *ICartsProductsRepoMock) GetCartsProductsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartsProducts.afterGetCartsProductsCounter)
}

// GetCartsProductsBeforeCounter returns a count of ICartsProductsRepoMock.GetCartsProducts invocations
func (mmGetCartsProducts *ICartsProductsRepoMock) GetCartsProductsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartsProducts.beforeGetCartsProductsCounter)
}

// Calls returns a list of arguments used in each call to ICartsProductsRepoMock.GetCartsProducts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartsProducts *mICartsProductsRepoMockGetCartsProducts) Calls() []*ICartsProductsRepoMockGetCartsProductsParams {
	mmGetCartsProducts.mutex.RLock()

	argCopy := make([]*ICartsProductsRepoMockGetCartsProductsParams, len(mmGetCartsProducts.callArgs))
	copy(argCopy, mmGetCartsProducts.callArgs)

	mmGetCartsProducts.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartsProductsDone returns true if the count of the GetCartsProducts invocations corresponds
// the number of defined expectations
func (m *ICartsProductsRepoMock) MinimockGetCartsProductsDone() bool {
	for _, e := range m.GetCartsProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartsProductsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartsProductsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartsProducts != nil && mm_atomic.LoadUint64(&m.afterGetCartsProductsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartsProductsInspect logs each unmet expectation
func (m *ICartsProductsRepoMock) MinimockGetCartsProductsInspect() {
	for _, e := range m.GetCartsProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.GetCartsProducts with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartsProductsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartsProductsCounter) < 1 {
		if m.GetCartsProductsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ICartsProductsRepoMock.GetCartsProducts")
		} else {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.GetCartsProducts with params: %#v", *m.GetCartsProductsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartsProducts != nil && mm_atomic.LoadUint64(&m.afterGetCartsProductsCounter) < 1 {
		m.t.Error("Expected call to ICartsProductsRepoMock.GetCartsProducts")
	}
}

type mICartsProductsRepoMockUpdateCartProduct struct {
	mock               *ICartsProductsRepoMock
	defaultExpectation *ICartsProductsRepoMockUpdateCartProductExpectation
	expectations       []*ICartsProductsRepoMockUpdateCartProductExpectation

	callArgs []*ICartsProductsRepoMockUpdateCartProductParams
	mutex    sync.RWMutex
}

// ICartsProductsRepoMockUpdateCartProductExpectation specifies expectation struct of the ICartsProductsRepo.UpdateCartProduct
type ICartsProductsRepoMockUpdateCartProductExpectation struct {
	mock    *ICartsProductsRepoMock
	params  *ICartsProductsRepoMockUpdateCartProductParams
	results *ICartsProductsRepoMockUpdateCartProductResults
	Counter uint64
}

// ICartsProductsRepoMockUpdateCartProductParams contains parameters of the ICartsProductsRepo.UpdateCartProduct
type ICartsProductsRepoMockUpdateCartProductParams struct {
	ctx    context.Context
	sku    uint64
	count  uint32
	cartID uint32
}

// ICartsProductsRepoMockUpdateCartProductResults contains results of the ICartsProductsRepo.UpdateCartProduct
type ICartsProductsRepoMockUpdateCartProductResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for ICartsProductsRepo.UpdateCartProduct
func (mmUpdateCartProduct *mICartsProductsRepoMockUpdateCartProduct) Expect(ctx context.Context, sku uint64, count uint32, cartID uint32) *mICartsProductsRepoMockUpdateCartProduct {
	if mmUpdateCartProduct.mock.funcUpdateCartProduct != nil {
		mmUpdateCartProduct.mock.t.Fatalf("ICartsProductsRepoMock.UpdateCartProduct mock is already set by Set")
	}

	if mmUpdateCartProduct.defaultExpectation == nil {
		mmUpdateCartProduct.defaultExpectation = &ICartsProductsRepoMockUpdateCartProductExpectation{}
	}

	mmUpdateCartProduct.defaultExpectation.params = &ICartsProductsRepoMockUpdateCartProductParams{ctx, sku, count, cartID}
	for _, e := range mmUpdateCartProduct.expectations {
		if minimock.Equal(e.params, mmUpdateCartProduct.defaultExpectation.params) {
			mmUpdateCartProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCartProduct.defaultExpectation.params)
		}
	}

	return mmUpdateCartProduct
}

// Inspect accepts an inspector function that has same arguments as the ICartsProductsRepo.UpdateCartProduct
func (mmUpdateCartProduct *mICartsProductsRepoMockUpdateCartProduct) Inspect(f func(ctx context.Context, sku uint64, count uint32, cartID uint32)) *mICartsProductsRepoMockUpdateCartProduct {
	if mmUpdateCartProduct.mock.inspectFuncUpdateCartProduct != nil {
		mmUpdateCartProduct.mock.t.Fatalf("Inspect function is already set for ICartsProductsRepoMock.UpdateCartProduct")
	}

	mmUpdateCartProduct.mock.inspectFuncUpdateCartProduct = f

	return mmUpdateCartProduct
}

// Return sets up results that will be returned by ICartsProductsRepo.UpdateCartProduct
func (mmUpdateCartProduct *mICartsProductsRepoMockUpdateCartProduct) Return(u1 uint64, err error) *ICartsProductsRepoMock {
	if mmUpdateCartProduct.mock.funcUpdateCartProduct != nil {
		mmUpdateCartProduct.mock.t.Fatalf("ICartsProductsRepoMock.UpdateCartProduct mock is already set by Set")
	}

	if mmUpdateCartProduct.defaultExpectation == nil {
		mmUpdateCartProduct.defaultExpectation = &ICartsProductsRepoMockUpdateCartProductExpectation{mock: mmUpdateCartProduct.mock}
	}
	mmUpdateCartProduct.defaultExpectation.results = &ICartsProductsRepoMockUpdateCartProductResults{u1, err}
	return mmUpdateCartProduct.mock
}

// Set uses given function f to mock the ICartsProductsRepo.UpdateCartProduct method
func (mmUpdateCartProduct *mICartsProductsRepoMockUpdateCartProduct) Set(f func(ctx context.Context, sku uint64, count uint32, cartID uint32) (u1 uint64, err error)) *ICartsProductsRepoMock {
	if mmUpdateCartProduct.defaultExpectation != nil {
		mmUpdateCartProduct.mock.t.Fatalf("Default expectation is already set for the ICartsProductsRepo.UpdateCartProduct method")
	}

	if len(mmUpdateCartProduct.expectations) > 0 {
		mmUpdateCartProduct.mock.t.Fatalf("Some expectations are already set for the ICartsProductsRepo.UpdateCartProduct method")
	}

	mmUpdateCartProduct.mock.funcUpdateCartProduct = f
	return mmUpdateCartProduct.mock
}

// When sets expectation for the ICartsProductsRepo.UpdateCartProduct which will trigger the result defined by the following
// Then helper
func (mmUpdateCartProduct *mICartsProductsRepoMockUpdateCartProduct) When(ctx context.Context, sku uint64, count uint32, cartID uint32) *ICartsProductsRepoMockUpdateCartProductExpectation {
	if mmUpdateCartProduct.mock.funcUpdateCartProduct != nil {
		mmUpdateCartProduct.mock.t.Fatalf("ICartsProductsRepoMock.UpdateCartProduct mock is already set by Set")
	}

	expectation := &ICartsProductsRepoMockUpdateCartProductExpectation{
		mock:   mmUpdateCartProduct.mock,
		params: &ICartsProductsRepoMockUpdateCartProductParams{ctx, sku, count, cartID},
	}
	mmUpdateCartProduct.expectations = append(mmUpdateCartProduct.expectations, expectation)
	return expectation
}

// Then sets up ICartsProductsRepo.UpdateCartProduct return parameters for the expectation previously defined by the When method
func (e *ICartsProductsRepoMockUpdateCartProductExpectation) Then(u1 uint64, err error) *ICartsProductsRepoMock {
	e.results = &ICartsProductsRepoMockUpdateCartProductResults{u1, err}
	return e.mock
}

// UpdateCartProduct implements carts_products_repo.ICartsProductsRepo
func (mmUpdateCartProduct *ICartsProductsRepoMock) UpdateCartProduct(ctx context.Context, sku uint64, count uint32, cartID uint32) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmUpdateCartProduct.beforeUpdateCartProductCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCartProduct.afterUpdateCartProductCounter, 1)

	if mmUpdateCartProduct.inspectFuncUpdateCartProduct != nil {
		mmUpdateCartProduct.inspectFuncUpdateCartProduct(ctx, sku, count, cartID)
	}

	mm_params := &ICartsProductsRepoMockUpdateCartProductParams{ctx, sku, count, cartID}

	// Record call args
	mmUpdateCartProduct.UpdateCartProductMock.mutex.Lock()
	mmUpdateCartProduct.UpdateCartProductMock.callArgs = append(mmUpdateCartProduct.UpdateCartProductMock.callArgs, mm_params)
	mmUpdateCartProduct.UpdateCartProductMock.mutex.Unlock()

	for _, e := range mmUpdateCartProduct.UpdateCartProductMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmUpdateCartProduct.UpdateCartProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCartProduct.UpdateCartProductMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCartProduct.UpdateCartProductMock.defaultExpectation.params
		mm_got := ICartsProductsRepoMockUpdateCartProductParams{ctx, sku, count, cartID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCartProduct.t.Errorf("ICartsProductsRepoMock.UpdateCartProduct got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCartProduct.UpdateCartProductMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCartProduct.t.Fatal("No results are set for the ICartsProductsRepoMock.UpdateCartProduct")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmUpdateCartProduct.funcUpdateCartProduct != nil {
		return mmUpdateCartProduct.funcUpdateCartProduct(ctx, sku, count, cartID)
	}
	mmUpdateCartProduct.t.Fatalf("Unexpected call to ICartsProductsRepoMock.UpdateCartProduct. %v %v %v %v", ctx, sku, count, cartID)
	return
}

// UpdateCartProductAfterCounter returns a count of finished ICartsProductsRepoMock.UpdateCartProduct invocations
func (mmUpdateCartProduct *ICartsProductsRepoMock) UpdateCartProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCartProduct.afterUpdateCartProductCounter)
}

// UpdateCartProductBeforeCounter returns a count of ICartsProductsRepoMock.UpdateCartProduct invocations
func (mmUpdateCartProduct *ICartsProductsRepoMock) UpdateCartProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCartProduct.beforeUpdateCartProductCounter)
}

// Calls returns a list of arguments used in each call to ICartsProductsRepoMock.UpdateCartProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCartProduct *mICartsProductsRepoMockUpdateCartProduct) Calls() []*ICartsProductsRepoMockUpdateCartProductParams {
	mmUpdateCartProduct.mutex.RLock()

	argCopy := make([]*ICartsProductsRepoMockUpdateCartProductParams, len(mmUpdateCartProduct.callArgs))
	copy(argCopy, mmUpdateCartProduct.callArgs)

	mmUpdateCartProduct.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCartProductDone returns true if the count of the UpdateCartProduct invocations corresponds
// the number of defined expectations
func (m *ICartsProductsRepoMock) MinimockUpdateCartProductDone() bool {
	for _, e := range m.UpdateCartProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCartProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCartProductCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCartProduct != nil && mm_atomic.LoadUint64(&m.afterUpdateCartProductCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCartProductInspect logs each unmet expectation
func (m *ICartsProductsRepoMock) MinimockUpdateCartProductInspect() {
	for _, e := range m.UpdateCartProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.UpdateCartProduct with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCartProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCartProductCounter) < 1 {
		if m.UpdateCartProductMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ICartsProductsRepoMock.UpdateCartProduct")
		} else {
			m.t.Errorf("Expected call to ICartsProductsRepoMock.UpdateCartProduct with params: %#v", *m.UpdateCartProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCartProduct != nil && mm_atomic.LoadUint64(&m.afterUpdateCartProductCounter) < 1 {
		m.t.Error("Expected call to ICartsProductsRepoMock.UpdateCartProduct")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ICartsProductsRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddProductToCartInspect()

		m.MinimockDeleteProductFromCartInspect()

		m.MinimockGetCartProductInspect()

		m.MinimockGetCartProductCountInspect()

		m.MinimockGetCartsProductsInspect()

		m.MinimockUpdateCartProductInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ICartsProductsRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ICartsProductsRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddProductToCartDone() &&
		m.MinimockDeleteProductFromCartDone() &&
		m.MinimockGetCartProductDone() &&
		m.MinimockGetCartProductCountDone() &&
		m.MinimockGetCartsProductsDone() &&
		m.MinimockUpdateCartProductDone()
}
